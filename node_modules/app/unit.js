'use strict';

const extend = require('extend');

module.exports = (function() {
    game.on('turn-start', function() {
        game.players.forEach(function(player) {
            player.units.forEach(function(unit) {
                if (unit.busy) {
                    unit.busy--;

                    if (unit.busy <= 0) {
                        unit.currentAction.complete(unit);
                    }
                }

                unit.movesLeft = unit.movement;
                unit.inactive = false;
            });

            game.emit('unit-activate-next', player);
        });
    });

    game.on('unit-activate', function(unit) {
        unit.player.activeUnit = unit;
        unit.active = true;
        unit.inactive = false;
    });

    game.on('unit-moved', function(unit) {
        if (unit.movesLeft === 0) {
            unit.player.activeUnit = false;
            unit.active = false;
            unit.inactive = true;

            game.emit('unit-activate-next', unit.player);
        }
    });

    game.on('unit-destroyed', function(unit) {
        game.emit('unit-activate-next', unit.player);
    });

    game.on('unit-activate-next', function(player) {
        if (game.currentPlayer.unitsToAction.length) {
            game.emit('unit-activate', game.currentPlayer.unitsToAction[0]);
        }
        else {
            game.emit('turn-over');
        }
    });

    var Unit = class Unit {
        constructor(details) {
            var unit = this;

            extend(unit, Unit.getByName(details.unit));
            extend(unit, details);
            unit.actions = {};

            unit.destroyed = false;

            unit.player.units.push(unit);

            Object.keys(Unit.availableActions).forEach(function(actionName) {
                var action = Unit.availableActions[actionName];

                if (!action.availableTo || ((!action.availableTo.include || (!action.availableTo.include.length || action.availableTo.include.includes(unit.name))) && (!action.availableTo.exclude || (!action.availableTo.exclude.length || !action.availableTo.exclude.includes(unit.name))))) {
                    unit.actions[action.name] = action;
                }
            });

            game.emit('unit-created', unit);
        }

        validateMove(to) {
            var neighbours = this.tile.neighbours;

            if (this.movesLeft === 0) {
                return false;
            }

            if (!Object.keys(neighbours).map(function(position) {
                return neighbours[position];
            }).includes(to)) {
                return false;
            }

            if (to.terrain.ocean && this.land) {
                return false;
            }

            if (to.terrain.land && this.ocean) {
                // TODO: transportation units
                return false;
            }

            // TODO: enemy units
            // TODO: adjacency rules

            // TODO
            if (to.movementCost > this.movesLeft) {
                if (Math.random() > (this.movesLeft / to.movementCost)) {
                    return false;
                }
            }

            return true;
        }

        move(to) {
            var unit = this;

            if (['n', 'ne', 'e', 'se', 's', 'sw', 'w', 'nw'].includes(to)) {
                to = unit.tile.neighbours[to];
            }

            if (unit.validateMove(to)) {
                unit.tile.units = unit.tile.units.filter(function(tileUnit) {
                    return tileUnit !== unit;
                });

                unit.tile = to;
                unit.tile.units.push(unit);

                unit.movesLeft--;

                game.emit('unit-moved', unit);
            }
            else {
                console.log("Can't move " + unit.player.people + " " + unit.title + " from " + unit.tile.x + "," + unit.tile.y + " to " + to.x + "," + to.y);
                // play sound
            }
        }

        action(action) {
            if (this.can(action)) {
                this.actions[action].run(this);

                game.emit('unit-moved', this);
            }
            else {
                console.log("Can't call action " + action + " on " + this.player.people + " " + this.title);
            }
        }

        can(action) {
            return action in this.actions;
        }

        destroy() {
            var unit = this;

            unit.player.units = unit.player.units.filter(function(playerUnit) {
                return playerUnit !== unit
            });

            unit.tile.units = unit.tile.units.filter(function(tileUnit) {
                return tileUnit !== unit;
            });

            unit.active = false;
            unit.destroyed = true;

            game.emit('unit-destroyed', unit);
        }
    };

    Unit.availableActions = {
        sentry: {
            name: 'sentry',
            title: 'Sentry',
            turns: 0,
            key: 's',
            availableTo: {},
            run: function(unit) {
                unit.inactive = true;
                unit.style = {
                    opacity:.5
                };
            }
        },
        fortify: {
            name: 'fortify',
            title: 'Fortify',
            turns: 1,
            key: 'f',
            availableTo: {
                exclude: ['settler']
            },
            run: function(unit) {
                unit.inactive = true;
                unit.fortified = true;
            }
        },
        disband: {
            name: 'disband',
            title: 'Disband',
            turns: 0,
            key: 'shift+d',
            availableTo: {},
            run: function(unit) {
                unit.destroy();
            }
        },
        pillage: {
            name: 'pillage',
            title: 'Pillage',
            turns: 1,
            key: 'shift+p',
            availableTo: {},
            run: function(unit) {
                // TODO
                game.emit('tile-improvement-pillaged', unit.tile, unit.tile.improvements[0]);
            }
        },
        noOrders: {
            name: 'noOrders',
            title: 'No orders',
            turns: 0,
            key: 'space',
            availableTo: {},
            run: function(unit) {
                unit.movesLeft = 0;
            }
        },
        buildCity: {
            name: 'buildCity',
            title: 'Build city',
            turns: 0,
            key: 'b',
            availableTo: {
                include: ['settler']
            },
            run: function(unit) {
                new game.city({
                    player: unit.player,
                    tile: unit.tile,
                    // TODO
                    name: 'London'
                });

                unit.destroy();
            }
        },
        irrigate: {
            name: 'irrigate',
            title: 'Build irrigation',
            turns: 2,
            key: 'i',
            availableTo: {
                include: ['settler']
            },
            run: function(unit) {
                if (!unit.tile.improvements.includes('irrigation') && unit.tile.terrain.improvements.irrigation && Object.keys(unit.tile.adjacent).map(function(direction) {
                    return unit.tile.adjacent[direction];
                }).filter(function(tile) {
                    return tile.terrain.name === 'river' || (tile.improvements.includes('irrigation') && !tile.city) || tile.terrain.ocean
                }).length) {
                    unit.status = this.key;
                    // TODO: terrain modifier
                    unit.busy = this.turns;
                    unit.movesLeft = 0;
                    unit.currentAction = this;
                }
            },
            complete: function(unit) {
                unit.currentAction = unit.busy = false;
                game.emit('tile-improvement-built', unit.tile, 'irrigation');
            }
        },
        road: {
            name: 'road',
            title: 'Build road',
            turns: 1,
            key: 'r',
            availableTo: {
                include: ['settler']
            },
            run: function(unit) {
                if (!unit.tile.improvements.includes('road') && unit.tile.terrain.improvements.road) {
                    unit.status = this.key;
                    // TODO: terrain modifier
                    unit.busy = this.turns;
                    unit.movesLeft = 0;
                    unit.currentAction = this;
                }
            },
            complete: function(unit) {
                unit.currentAction = unit.busy = false;
                game.emit('tile-improvement-built', unit.tile, 'road');
            }
        },
        mine: {
            name: 'mine',
            title: 'Build mine',
            turns: 3,
            key: 'm',
            availableTo: {
                include: ['settler']
            },
            run: function(unit) {
                if (!unit.tile.improvements.includes('mine') && unit.tile.terrain.improvements.mine) {
                    unit.status = this.key;
                    // TODO: terrain modifier
                    unit.busy = this.turns;
                    unit.movesLeft = 0;
                    unit.currentAction = this;
                }
            },
            complete: function(unit) {
                unit.currentAction = unit.busy = false;
                game.emit('tile-improvement-built', unit.tile, 'mine');
            }
        }
    };

    Unit.units = [];

    Unit.getByName = function(name) {
        return Unit.units.filter(function(unit) {
            return unit.name === name;
        })[0];
    };

    game.plugin.get('unit').forEach(function(unit) {
        unit.contents.forEach(function(file) {
            Unit.units.push(game.loadJSON(file));
        });
    });

    return Unit;
})();

