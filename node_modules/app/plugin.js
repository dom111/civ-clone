'use strict';

const fs = require('fs');
const extend = require('extend');
var plugins = {};

module.exports = (function() {
    return {
        load: function(game) {
            console.log('called');
            fs.readdirSync(game.path('enabledPlugins')).filter(function(name) {
                // skip hidden files
                // TODO: check if file has hidden attribute?
                return !(name.match(/^\./))
            })
            // map each foldername and load the plugin.json for each file
            .map(function(plugin) {
                // load each enabled plugin's definition
                return extend({}, game.loadJSON(game.path('enabledPlugins') +  plugin + '/plugin.json'), {
                    // keep the path for use when loading the components
                    __path: game.path('enabledPlugins') + plugin + '/'
                });
            })
            // sort by plugin weight
            .sort(function(a, b) {
                // order by the weighting to allow incremental updates
                return (a.weight > b.weight) ?
                    1 : (a.weight === b.weight) ?
                    0 : -1;
            })
            // filter out any plugins missing dependencies
            // TODO: this is proably VERY innefficient, especially the .map()s
            .filter(function(pluginData, i, pluginArray) {
                return (pluginData.dependencies || []).map(function(dependency) {
                    return pluginArray.map(function(pluginData) {
                        return dependency === pluginData.name;
                    })
                    // only one plugin needs to match the dependency...
                    .some(function(value) {
                        return value === true
                    });
                })
                // ...but all dependencies must be matched
                .every(function(value) {
                    return value === true
                });
            })
            // loop around our final list of dependency checked plugins
            .forEach(function(pluginData) {
                (pluginData.components || []).sort(function(a, b) {
                    return ((a.weight || 0) > (b.weight || 0)) ?
                        1 : ((a.weight || 0) === (b.weight || 0)) ?
                        0 : -1;
                }).forEach(function(component) {
                    // expand content files into full paths for reading
                    component.contents = (component.contents || []).map(function(file) {
                        return (file.substr(0) === '/') ? file : (pluginData.__path + file);
                    });

                    if (!(component.type in plugins)) {
                        plugins[component.type] = [];
                    }

                    plugins[component.type].push(component);
                });
            });

        },
        get: function(pluginType) {
            if (typeof pluginType !== 'undefined') {
                return (plugins[pluginType] || []);
            }
            else {
                return plugins;
            }
        }
    }
})();
