'use strict';

const fs = require('fs');
const extend = require('extend');
var plugins = {};
var loadedPlugins = [];

module.exports = (function() {
    var Plugin = class Plugin {
        constructor(data) {
            extend(this, data);
        }

        get(type, label) {
            var plugin = this;

            return Plugin.get(type).filter(function(component) {
                var check = component.package === plugin.package;

                if (label) {
                    check = check && (component.label === label);
                }

                return check;
            });
        }
    };

    extend(Plugin, {
        load: function(game) {
            fs.readdirSync(game.path('enabledPlugins')).filter(function(name) {
                // skip hidden files
                // TODO: check if file has hidden attribute?
                return !(name.match(/^\./))
            })
            // map each foldername and load the plugin.json for each file
            .map(function(plugin) {
                // load each enabled plugin's definition
                return extend({}, game.loadJSON(game.path('enabledPlugins') +  plugin + '/plugin.json'), {
                    // keep the path for use when loading the components
                    __path: game.path('enabledPlugins') + plugin + '/'
                });
            })
            // sort by plugin weight
            .sort(function(a, b) {
                // order by the weighting to allow incremental updates
                return ((a.weight || 0) > (b.weight || 0)) ?
                    1 : ((a.weight || 0) === (b.weight || 0)) ?
                    0 : -1;
            })
            // filter out any plugins missing dependencies
            // TODO: this is proably VERY innefficient, especially the .map()s
            .filter(function(pluginData, i, pluginArray) {
                return (pluginData.dependencies || []).map(function(dependency) {
                    return pluginArray.map(function(pluginData) {
                        return dependency === pluginData.name;
                    })
                    // only one plugin needs to match the dependency...
                    .some(function(value) {
                        return value === true
                    });
                })
                // ...but all dependencies must be matched
                .every(function(value) {
                    return value === true
                });
            })
            // loop around our final list of dependency checked plugins
            .forEach(function(pluginData) {
                loadedPlugins.push(pluginData.name);

                (pluginData.components || []).sort(function(a, b) {
                    return ((a.weight || 0) > (b.weight || 0)) ?
                        1 : ((a.weight || 0) === (b.weight || 0)) ?
                        0 : -1;
                }).forEach(function(component) {
                    // expand content files into full paths for reading
                    component.contents = (component.contents || []).map(function(file) {
                        return (file.substr(0) === '/') ? file : (pluginData.__path + file);
                    });

                    component.package = pluginData.name;
                    component.__path = pluginData.__path;

                    if (!(component.type in plugins)) {
                        plugins[component.type] = [];
                    }

                    plugins[component.type].push(new Plugin(component));
                });
            });
        },
        get: function(pluginType) {
            if (typeof pluginType !== 'undefined') {
                return (plugins[pluginType] || []);
            }
            else {
                return plugins;
            }
        },
        loaded: function(name) {
            return loadedPlugins.includes(name);
        }
    });

    return Plugin;
})();
