'use strict';

// external objects
const EventEmitter = require('events');
const util = require('util');
const electron = require('electron');
const ipc = electron.ipcRenderer;
const extend = require('extend');
const mustache = require('mustache');
const fs = require('fs');
const vm = require('vm');

module.exports = (function() {
    // private variables
    var _paths = {};
    var _settings = {};
    var _plugins = {};
    var _loadedPlugins = [];

    // private methods
    var _path(name, path) {
        if (path) {
            _paths[name] = path;
        }

        return (name in _paths) ? _paths[name] : ipc.sendSync('app.getPath', name);
    };

    var Engine = class Engine {
        constructor() {
            EventEmitter.call(this);

            this.availableTradeRates = [];

            // set up useful paths
            _path('base', `${__dirname}/../../`);
            _path('views', _path('base') + 'views/');
            _path('plugins', _path('base') + 'plugins/');
            _path('enabledPlugins', _path('plugins') + 'enabled/');
            _path('settingsFile', _path('userData') + '/settings.json');

            // load Settings
            extend(_settings, this.loadJSON(_path('settingsFile')) || {});

            // get or set default locale to load correct language
            // TODO: this will load no text in most locales, need to set a default?
            this.setting('locale', ipc.sendSync('app.getLocale'));

            this.loadPlugins();
            Engine.Plugin.load(this);
        }

        define(key, value) {
            if (key in this) {
                throw `Can't redefine ${key}, perhaps you need to call extend?.`;
            }
            else {
                this[key] = value;
            }
        }

        extend(key, value) {
            if (!key in this) {
                return this.define(key, value);
            }
            else {
                return extend(this[key], value);
            }
        }

        setting(key, value) {
            return _settings[key] || (value ? this.setSetting(key, value) : value);
        }

        setSetting(key, value) {
            if (_settings[key] !== value) {
                _settings[key] = value;

                this.saveJSON(_path('settingsFile'), _settings)
            }

            return settings[key];
        }

        get isTurnEnd() {
            return this.currentPlayer.actionsLeft === 0;
        }

        loadPlugins() {
            var engine = this;

            engine.context = extend({}, global, {
                fs: fs, // TODO: sandboxed FS
                extend: extend,
                require: function() {
                    throw 'require() is disabled for security reasons.';
                },
                addEventListener: function(event, method) {
                    // TODO: I'm clearly not supposed to do this...
                    return global.addEventListener(event, method);
                },
                setInterval: function(code, delay) {
                    // TODO: I'm clearly not supposed to do this...
                    return global.setInterval(code, delay);
                },
                console: console,
                global: global,
                // allows plugins to use these as if they already exist in scope
                engine: engine,
                Engine: Engine
            });

            Engine.Plugin.get('game-modifier').forEach(function(plugin) {
                (plugin.contents || []).forEach(function(component) {
                    var code = fs.readFileSync(component);
                    vm.runInContext(code, vm.createContext(extend({
                        plugin: plugin,
                        component: component
                    }, engine.context, plugin, component)), 'file://' + component);
                });
            });
        }

        start(options) {
            var engine = this;

            engine.defaultOptions = {
                // TODO
                players: 1,
                difficulty: 1,
                endOfTurn: false
            };

            engine.options = extend({}, engine.defaultOptions, options);
            engine.players = [];
            engine.map = new engine.World();

            engine.on('start', function() {
                engine.emit('turn-start');
            });

            engine.on('turn-start', function() {
                engine.notifications.check();
            });

            engine.on('turn-end', function() {
                // TODO: more calculations?
                engine.emit('turn-start');
            });

            engine.on('turn-over', function() {
                if (this.options.endOfTurn) {
                    console.log('End turn');
                }
                else {
                    if (engine.isTurnEnd) {
                        engine.emit('turn-end');
                    }
                    else {
                        console.log('No auto end-turn because there are actions left: ' + engine.currentPlayer.actionsLeft);
                    }
                }
            });

            // engine.addPlayers(); // TODO
            for (var i = 0; i < engine.options.players; i++) {
                engine.players.push(engine.Player());
                // engine.players.push(engine.Player());
                // engine.players.push(engine.Player());
            }

            // TODO: this is testing data
            engine.currentPlayer = engine.players[0];

            new engine.Unit({
                unit: 'settler',
                tile: engine.map.get(3, 3),
                player: engine.currentPlayer
            });
            new engine.Unit({
                unit: 'settler',
                tile: engine.map.get(3, 3),
                player: engine.currentPlayer
            });
            new engine.Unit({
                unit: 'cavalry',
                tile: engine.map.get(3, 3),
                player: engine.currentPlayer
            });

            engine.emit('start');

            engine.started = true;
        }

        loadJSON(file) {
            file = (file.substr(0, 1) === '/') ? file : _path('base') + file;

            try {
                fs.accessSync(file);
                return JSON.parse(fs.readFileSync(file));
            }
            catch (e) {
                console.error(`Error loading '${file}': ${e}`);
            }
        }

        saveJSON(file, data) {
            file = (file.substr(0, 1) === '/') ? file : _path('base') + file;

            return fs.writeFileSync(file, JSON.stringify(data), 'utf8');
        }

        getTemplate(template, callback) {
            var file = _path('views') + template;
            try {
                fs.accessSync(file);
                return fs.readFileSync(file, 'utf8');
            }
            catch (e) {
                console.error(`Error loading '${_path('views')}${template}': ${e}`);
            }
        }

        template(template) {
            return mustache.render(this.getTemplate(template), {
                translations: this.translations
            });
        }
    };

    Engine.Plugin = class Plugin {
        constructor(data) {
            extend(this, data);
        }

        get(type, label) {
            var plugin = this;

            return Plugin.get(type).filter(function(component) {
                var check = component.package === plugin.package;

                if (label) {
                    check = check && (component.label === label);
                }

                return check;
            });
        }
    };

    extend(Engine.Plugin, {
        load: function(engine) {
            fs.readdirSync(_path('enabledPlugins')).filter(function(name) {
                // skip hidden files
                // TODO: check if file has hidden attribute?
                return !(name.match(/^\./))
            })
            // map each foldername and load the plugin.json for each file
            .map(function(plugin) {
                // load each enabled plugin's definition
                return extend({}, engine.loadJSON(_path('enabledPlugins') +  plugin + '/plugin.json'), {
                    // keep the path for use when loading the components
                    __path: _path('enabledPlugins') + plugin + '/'
                });
            })
            // sort by plugin weight
            .sort(function(a, b) {
                // order by the weighting to allow incremental updates
                return ((a.weight || 0) > (b.weight || 0)) ?
                    1 : ((a.weight || 0) === (b.weight || 0)) ?
                    0 : -1;
            })
            // filter out any plugins missing dependencies
            // TODO: this is proably VERY innefficient, especially the .map()s
            // would be great to order the plugins by some sort of inheritence
            // tree, to ensure dependents are loaded after the dependencies...
            .filter(function(pluginData, i, pluginArray) {
                // return (pluginData.dependencies || []).map(function(dependency) {
                //     return pluginArray.map(function(pluginData) {
                //         return dependency === pluginData.name;
                //     })
                //     // only one plugin needs to match the dependency...
                //     .some(function(value) {
                //         return value === true
                //     });
                // })
                // // ...but all dependencies must be matched
                // .every(function(value) {
                //     return value === true
                // });

                // TODO: would this \/ work the same as this /\ ?

                // all dependencies must be matched
                return (pluginData.dependencies || []).every(function(dependency) {
                    // ...but only one plugin needs to match the dependency...
                    return pluginArray.some(function(pluginData) {
                        return dependency === pluginData.name;
                    });
                });
            })
            // loop around our final list of dependency checked plugins
            .forEach(function(pluginData) {
                _loadedPlugins.push(pluginData.name);

                (pluginData.components || []).sort(function(a, b) {
                    return ((a.weight || 0) > (b.weight || 0)) ?
                        1 : ((a.weight || 0) === (b.weight || 0)) ?
                        0 : -1;
                }).forEach(function(component) {
                    // expand content files into full paths for reading
                    component.contents = (component.contents || []).map(function(file) {
                        return (file.substr(0) === '/') ? file : (pluginData.__path + file);
                    });

                    component.package = pluginData.name;
                    component.__path = pluginData.__path;

                    if (!(component.type in _plugins)) {
                        _plugins[component.type] = [];
                    }

                    _plugins[component.type].push(new Engine.Plugin(component));
                });
            });
        },
        get: function(pluginType) {
            if (typeof pluginType !== 'undefined') {
                return (_plugins[pluginType] || []);
            }
            else {
                return _plugins;
            }
        },
        loaded: function(name) {
            return _loadedPlugins.includes(name);
        }
    });


    util.inherits(Engine, EventEmitter);

    return Engine;
})();
