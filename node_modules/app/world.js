'use strict';

const extend = require('extend');
const EventEmitter = require('events');
const util = require('util');

module.exports = (function() {
    var Tile = class Tile {
        constructor(details) {
            EventEmitter.call(this);

            extend(this, details);

            if (!(this.map instanceof World)) {
                throw "Invalid Tile definition.";
            }

            this.improvements = [];

            this.on('improvement-built', function(improvement) {
                if (!this.improvements.includes(improvement)) {
                    this.improvements.push(improvement);
                }
            });

            this.on('improvement-pllaged', function(improvement) {
                if (this.improvements.includes(improvement)) {
                    this.improvements = this.improvements.filter(function(currentImprovement) {
                        return currentImprovement !== improvement;
                    });
                }
            });
        }

        get neighnours() {
            return {
                nw: this.map.get(this.x - 1, this.y - 1),
                n: this.map.get(this.x, this.y - 1),
                ne: this.map.get(this.x + 1, this.y - 1),
                e: this.map.get(this.x - 1, this.y),
                w: this.map.get(this.x + 1, this.y),
                sw: this.map.get(this.x - 1, this.y + 1),
                s: this.map.get(this.x, this.y + 1),
                se: this.map.get(this.x + 1, this.y + 1)
            };
        }

        isOceam() {
            return (this.terrainId === 0);
        }

        isCoast() {
            return this.isOcean() &&
                // cost is a tile that is ocean with land to the north, south, east or west, diagonals don't affect the coastal status
                ['n', 'e', 's', 'w'].map(function(direction) {
                // if we do need to check all, we could do:
                // Object.keys(this.neighbours).map(function(direction) {
                    return this.neighbours[direction].isLand()
                }).some(function(value) {
                    return value === true;
                });
        }

        isLand() {
            return (this.terrainId > 0)
        }

        resource(type) {
            var tile = this;

            if ((typeof tile.terrain[type] === 'function')) {
                tile.terrain[type] = tile.terrain[type](tile.map, tile.x, tile.y);
            }

            return (this.terrain[type] + tile.improvements.map(function(improvement) {
                return tile.terrain.improvements[improvement][type] || 0;
            }).reduce(function(total, value) {
                return total + value;
            }, 0)) || 0;
        }

        get trade() {
            return this.resource('trade');
        }

        get food() {
            return this.resource('food');
        }

        get production() {
            return this.resource('production');
        }
    };

    util.inherits(Tile, EventEmitter);

    var World = class World {
        constructor() {
            EventEmitter.call(this);

            var map = this;

            this.map = World.generate().map(function(row, x) {
                return row.map(function(terrainId, y) {
                    return new Tile(extend({
                        x: x,
                        y: y,
                        terrainId: terrainId,
                        terrain: World.getTerrainType(terrainId),
                        map: map
                    }));
                });
            });

            this.seed = Math.ceil(Math.random() * 1e7);
        }

        get(x, y) {
            return (this.map[x] || [])[y] || false;
        }

        static getTerrainType(id) {
            return World.getTerrainTypes()[id];
        }

        static getTerrainTypes() {
            return {
                0: {
                    name: 'Ocean',
                    food: 1,
                    trade: 2,
                    production: 0,
                    improvements: {}
                },
                1: {
                    name: 'Grassland',
                    food: 2,
                    trade: 0,
                    production: function(map, x, y) {
                        // TODO
                        return ((game.map.seed + ((x + 1) * (y + 1))).toString(2).substr(-2) === '11') ? 1 : 0;
                    },
                    improvements: {
                        irrigation: {
                            food: 1
                        },
                        road: {
                            trade: 1
                        }
                    }
                },
                2: {
                    name: 'River',
                    food: 2,
                    trade: 1,
                    production: function(map, x, y) {
                        // TODO
                        return ((game.map.seed + ((x + 1) * (y + 1))).toString(2).substr(-2) === '11') ? 1 : 0;
                    },
                    improvements: {
                        irrigation: {
                            food: 1
                        },
                        road: {
                            trade: 1
                        }
                    }
                },
                3: {
                    name: 'Hills',
                    food: 1,
                    trade: 0,
                    production: 1,
                    improvements: {
                        mine: {
                            production: 2
                        },
                        irrigation: {
                            food: 1
                        },
                        road: {}
                    }
                },
                4: {
                    name: 'Desert',
                    food: 0,
                    trande: 0,
                    production: 1,
                    improvements: {
                        irrigation: {
                            food: 1
                        },
                        road: {
                            trade: 1
                        },
                        mine: {
                            production: 1
                        }
                    }
                }
            }
        }

        static generate(options) {
            // TODO
            return [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,1,1,0,0,0,0,0,3,0,0,0,0],
                [0,1,2,2,1,1,4,1,1,1,0,0,0,3,0,0],
                [0,0,1,1,1,1,4,4,1,1,1,1,1,1,3,0],
                [1,0,1,1,1,1,1,4,1,1,1,1,3,1,0,0],
                [1,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1],
                [1,1,1,1,4,0,0,0,0,0,2,1,1,0,1,1],
                [1,1,1,2,4,1,0,0,0,2,2,2,1,0,0,1],
                [0,1,1,1,4,3,3,0,0,0,2,2,2,1,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0],
                [0,1,0,1,1,1,1,1,1,4,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,4,4,4,4,1,1,1,1],
                [1,1,1,1,1,1,1,1,4,1,4,1,1,2,1,1],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,2,1,1],
                [0,1,1,0,0,0,0,0,0,0,0,1,1,3,3,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ];
        }

        static load() {
            // TODO
        }
    };

    util.inherits(World, EventEmitter);

    return World;
})();

